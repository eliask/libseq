/////////////////////////////////////////////////////////////////////////////
//                                                                         
// Permutation.h, 8.8.99, Ilja Friedel                       
//
/////////////////////////////////////////////////////////////////////////////
//                                                                         
// Status: ok
//
/////////////////////////////////////////////////////////////////////////////

#ifndef PERMUTATION_USED
#define PERMUTATION_USED

#include <stdio.h>
#include <assert.h>
#include "own_types.h"
#include "options.h"
#include "digit_gen.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class Permutation
{
protected:
   UL_int  base;
   UL_int  memory;

public:
   R_Elem         *X;
   inline         Permutation(UL_int);
   virtual       ~Permutation();
   UL_int         Base(void)       {return(base);}
   UL_int         memory_used(void){return(memory);}
   inline  void   print(void);
   virtual R_Elem operator[](const UL_int j);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class RandomPermutation : public Permutation
{
protected:
   Rng * rng;
public:
   inline        RandomPermutation(const UL_int b, Rng * rng_ptr):Permutation(b){rng = rng_ptr;}
   virtual void  operator++(void);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class VectorRandomPermutation : public RandomPermutation
{
   RandomPermutation *P[32];
   UL_int             N[32];
   UL_int             dim;
   UL_int             dim_base;

public:
   inline        VectorRandomPermutation(UL_int, UL_int, Rng *);
   virtual      ~VectorRandomPermutation();
          void   operator++(void);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class LazyRandomPermutation : public RandomPermutation
{
   UL_int  left,right,single;
   int clean,newPerm;

public:
   inline        LazyRandomPermutation(const UL_int b, Rng * rng_ptr);
          void   operator++(void);
          R_Elem operator[](const UL_int j);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// and now the inline functions ...
/////////////////////////////////////////////////////////////////////////////

inline Permutation::Permutation(UL_int b)
{
   L_int i;

   X = new R_Elem[b];
   if(X==NULL)
     {
       cerr << "Error: Out of memory! (Permutation(" << b << ")" << endl;  
       exit(1);
     }
   for(i=0;i<b;i++) X[i]=i;
   base=b;
   memory=b*sizeof(R_Elem)+sizeof(Permutation);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

inline void Permutation::print(void)
{
   L_int i;

   cout << "Permutation: base=" << base << ", <";
   for(i=0;i<base-1;i++) cout << X[i] << " ";
   cout << X[base-1] << ">" << endl;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

inline VectorRandomPermutation::VectorRandomPermutation(UL_int b, UL_int n, Rng * rng_ptr):RandomPermutation(int_pow(b,n), rng_ptr)
{
   L_int i;

   for(i=0;i<n;i++) 
     {
       P[i]=new RandomPermutation(b, rng_ptr);
       if(P[i]==NULL)
	 {
	   cerr << "Error: Out of memory! ";
	   cerr << "(VectorRandomPermutation::VectorRandomPermutation())";
	   cerr << endl;
	   exit(1);
	 }
       memory+=P[i]->memory_used();
       N[i]=0;
     }

   dim      = n;
   dim_base = b;
   memory+=sizeof(VectorRandomPermutation);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

inline LazyRandomPermutation::LazyRandomPermutation(const UL_int b, Rng * rng_ptr):RandomPermutation(b, rng_ptr)
{
   clean   = 1;
   newPerm = 1;
   memory += sizeof(LazyRandomPermutation);
} 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#endif
